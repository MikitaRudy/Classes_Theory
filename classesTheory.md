Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?
**Ответ.** Для класса, не являющегося вложенным, может быть указан только один из двух возможных уровней доступа: 
заданный по умолчанию и public. Когда класс объявлен как public, 
он должен быть единственным public классом, объявленным в файле, 
и имя файла должно совпадать с именем класса.  
**Источник.** http://pr0java.blogspot.com/2015/07/1.html

Что является членами класса?
**Ответ.** Поля, методы и конструкторы.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html
 
Что еще можно определить в классе кроме членов?
**Ответ.** Блоки ипнициализации (нестатические и статические)
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
 
Какие уровни доступа есть у членов класса?
**Ответ.** private, package, protected, public.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html
 
Какие модификаторы необходимы для определения константы:
1. класса,
2. экземпляра класса?
**Ответ.** 1) static final 2) final.

Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
```
class SomeClass {
	private int a;
	private final int b;
private static int c;
private static final int D;
...
}
```
Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?
**Ответ.** 
	a - переменная экземпляра 
	b - константа экземпляра
	c - статическая переменная класса
	D - константа класса
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html

Может ли класс не иметь ни одного конструктора? Почему?
**Ответ.** Может, тогда компилятор неявно создаёт конструктор по умолчанию вида:
```
ClassName(){
	super();
}
```
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html
 
Перечислите отличия конструктора от метода.
**Ответ.** 
	1) именем является имя класса
	2) не указывается возвращаемое значение.
 
Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?
**Ответ.** В первой строке конструктора используя ключевое слово ```this()``` указав в скобках передаваемые параметры.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html
 
Как и в каком месте можно вызвать конструктор суперкласса?
**Ответ.** Его вызов должен находиться в первой строке конструктора субкласса и вызываться с испльзованием ключевого слова ```super()```, с указанием в скобках передаваемых параметров.
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html
 
Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?
**Ответ.** Неявно вызывает конструктор суперкласса.
**Источник.**

Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе?
Обоснуйте ответ.
**Ответ.** Нет.Если присутсвует, вызов другого конструктора должен быть в первой строке конструктора.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?
**Ответ.** Может, если мы хотим сделать класс неинстанцируемым или предоставить статический фабричный метод для создания его экземпляров, а так же если хотим предоставить пользователю один единственный экземпляр.
**Источник.** Joshua Bloch, Effective Java 2.1 , 2.2 , 2.3

Какие модификаторы может иметь конструктор?
**Ответ.** public, protected, no modifier, private.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

Конструктор принадлежит классу или экземпляру класса?
**Ответ.** Конструктор — особоый вида метод следовательно принадлежит классу.
**Источник.** Java_from_EPAM_Blinov_2020 с.71

Можно ли наследовать конструктор?
Если да, то приведите примеры. 
**Ответ.**
**Источник.**

Какой тип возвращаемого конструктором значения?
**Ответ.** Конструктор не имеет тип возвращаемого значения.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

Дан класс.
```
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
	//фрагмент 2
	Null() {
		return null;
	}
}
```
В каком фрагменте ошибка компиляции? 
**Ответ.** Во втором. Конструктор не имеет возвращаемого значения.
Удалите этот фрагмент полностью. 
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса. 
**Ответ.** Фрагмент 1 это метод с именем Null(), который возвращает null.
```
Null n = new Null();
System.out.println(n.Null());
```

Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?
**Ответ.** У конструктора отсутсвует тип возвращаемого значения.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

Дан класс.
```
class Name {
	String name;
	Name() {
		this(makeRandomName());
	}
	Name(String name) {
		super();
		this.name = name;
	}
	String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
```
Объясните причину ошибки компиляции.  
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.
**Ответ.** Вызывается метод экземпляра когда сам экземпляр ещё не сформирован ( не вызван конструктор суперкласса).
	1) Добавить методу makeRandomName() модификатор static.
	2) Заменить ```this(makeRandomName())``` на this.name = makeRandomName();

Дан класс.
```
class Int {
	int i;
	void inc(Int param) {
		//param = new Int();
		param.i++;
	}
	public static void main(String[] args) {
		Int obj = new Int();
		obj.inc(obj);
		System.out.println(obj.i);
	}
}
```
Изменится ли результат, если убрать комментарий?
Объясните, почему?
**Ответ.**Да, изменится. param является ссылкой на объект и когда мы присваиваем ей новое значение, то начинаем работать с новым объектом, а не тем, который был передан как параметр.

В чем смысл конструкции this?
Перечислите случаи, когда используется конструкция this.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?
**Ответ.** this является ссылкой на текущий объект.
**Ответ.**	
	1) Для вызова другого конструктора данного класса. (прим. ниже).
	2) Для явного указания на член класса(прим. ниже).
```
class A{
	int a;
	A(){
	}
	A(int a){
		this();
		this.a = a;
	}
}
```	
**Ответ.** Если в методе объявлена локальная переменная
или параметр метода с таким же именем, как и поле класса, то для обращения
к полю класса использование this обязательно
**Источник.** Java_from_EPAM_Blinov_2020 с.71

Можно ли присвоить null ссылочной переменной this?
**Ответ.** Нет.

Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?
**Ответ.** Для инициализации статических переменных или выполнения каких-либо действий один раз при создании класса.
**Ответ.** Написать приватный статический метод.
**Источник.** Java_from_EPAM_Blinov_2020 с.85
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
 
Перечислите случаи, когда используется логический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?
**Ответ.** Для инициализации всех остальных переменных или выполнения каких-либо действий при создании объекта класса.
**Ответ.** Инициализировать переменные в конструкторе.
**Источник.** Java_from_EPAM_Blinov_2020 с.85
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
 
Что входит в сигнатуру метода?
**Ответ.** Имя метода и типы парамаетров.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Что значит ключевое слово native?
**Ответ.** Сигнализирует о том, что функция является платформо-зависимой.
**Источник.** https://docs.oracle.com/en/java/javase/16/docs/specs/jni/intro.html#java-native-interface-overview

Дан код. 
```
public class BusinessTrip {
  …
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте. 
**Ответ.** Да, метод перевода из денежного представления в строку не относится к команидровке.

Дан код. 
```
public class Utility {
  private Utility() {
  }
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты. 
**Ответ.**Да, метод перевода из денежного представления в строку не относится конкретно к утилитному классу, следует сделать его статическим.

К каким данным можно обратиться в статическом методе?
**Ответ.** К любым статическим методам и полям.
**Источник.** Java_from_EPAM_Blinov_2020 c.81

Почему нельзя объявить статическое поле внутри метода?
**Ответ.** Метод принадлежит экземпляру класса, а статическое поле должно принадлежать классу.
**Источник.** Java_from_EPAM_Blinov_2020 c.81

Перечислите, какой код в классе можно выполнить до создания объекта.
**Ответ.** 
	1)Инициализацию статических переменных. 
	2)Инициализацю нестатических полей. 
	3)Любой код возможный в инициализаторах.
 
В чем различие между объектом и экземпляром класса?
**Ответ.** Объект: это копия класса. Экземпляр: это переменная, которая используется для хранения адреса памяти объекта.
**Источник.** https://coderoad.ru/2885385/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%BE%D0%BC-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%BC

Назовите три этапа создания экземпляра класса.
**Ответ.**
	1) Декларация. Декларирование переменной типа класса с уникальным именем.
	2) Инстанциация. Создание нового объекта с использованием ключевого слова ‘new’.
	3) Инициализация. Вызов конструкторов, который идёт после ключевого слова ‘new’.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html
 
Охарактеризуйте отношение композиции между классами? Как оно реализуется?
**Ответ.** Отношение типа 'ИМЕЕТ', объект является частью другого объекта. Реализуется добавлением в класс ссылочного поля нужного типа.
**Источник.** https://java-course.ru/begin/relations/
 
Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.
**Ответ.**
	1) Создать класс содержащий два значения этого типа (прим. ниже).
	2)
```
```

Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.
**Ответ.**
	1) Создать класс содержащий два значения этого типа (прим. ниже).
	2) 
```
```

Что такое иммутабельный объект? 
Опишите 2 способа создания иммутабельных объектов. 
Подсказка. Способ 1 - класс материала в classes2. 
Какой альтернативный? 
Подсказка - ключевое слово final для полей не использовать.
Создайте иммутабельный класс для вещества по альтернативному способу. 
**Ответ.**
	1) Запретить наследование класса и убрать все возможности изменения его полей.
```
public final class ImmutableType {
 private String name;
 private int id;
 public ImmutableType(String name, int id) {
 this.name = name;
 this.id = id;
 }
 public String getName() {
 return name;
 }
 public int getId() {
 return id;
 }
// equals, hashCode, toString
}
```
 	2) Использовать ключевое слово record.
```
public record ImmutableRec(String name, int id) {
 void method() {}
}
```
**Источник.** Java_from_EPAM_Blinov_2020 c.101	
	
Даны 2 класса.
```
final class Material {
	private final String name;
	private final double density;
	...
}
class Runner {
	private static void printMaterial(final Material material) {
        	System.out.println(material);
	}
	public static void main(String[] args) {
        	Material steel = new Material("steel",7850);
        	printMaterial(steel);
	}
}
```
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)? 
Какой пример можно использовать для обоснования ответа?
**Ответ.**
**Источник.**

Класс для комплексного числа содержит два поля:
```
class Complex {
	private double re;
	private double im;
	…
}
```
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
Реализуйте эти же методы при условии, что класс Complex является иммутабельным. 
**Ответ.**
```
```

Для чего предназначен метод toString()?
В каких случаях он вызывается?
**Ответ.** Для представления объекта строкой. Вызывается если требуется строковое представление объёкта (прим. метод System.out.print()).
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--

Как реализован метод toString() в классе Object?
**Ответ.** ```return getClass().getName() + '@' + Integer.toHexString(hashCode());```.
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--

Для чего предназначен метод equals()?
В каких случаях он вызывается?
**Ответ.** Для сравнения объектов на равенство. Вызывается если требуется определить равны ли объекты между собой ( равенство зависит от реализации).
**Источник.**  https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-

Как реализован метод equals() в классе Object?
**Ответ.** ```return (this == obj);```
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-

В чем различие между методом equals() и операции ==?
В каких случаях применение метода equals() и операции == эквивалентно?
**Ответ.** опреация == сравнивает равенство адресов на которые указывает ссылка (или значение по адресу для примитивных типов). Они эквивалентны если не переопределён метод Object.equals.

Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
С чем связаны данные проверки, которые кажутся лишними?
**Ответ.** Первая проверка избавляет от лишних действий если мы сравниваем объект с самим собой, вторая проверяет есть ли объект для сравнения.
 
Что такое garbage collection?
**Ответ.**  Сборщик мусора(GC) автоматически выполняет управление запросами на выделение динмаической памяти приложения а так же её очисткой.
**Источник.** https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm#JSGCT-GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304

Перечислите случаи, когда JVM отдает управление на garbage collector.
**Ответ.** Когда понимает что память на исходе или JVM останавливает работу. 
**Источник.**

Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?
**Ответ.** Нельзя начать сборку мусора по запросу, но можно использоваться ```System.gc()```. Хотя это не обещает, что сборка мусора начнётся сейчас или вообще произойдет, это скорее просьба JVM начать сборку мусора.
**Источник.** Joshua Bloch, Effective Java 2.8

Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти? 
Обоснуйте ответ.
**Ответ.** Нет, переполнение памяти возможно. например если приложение хранит ненужные ссылки или произошла утечка памяти. Так же такое возможно если GC не успевает удалять все ненужные объекты по какой-либо причине.
**Источник.** Joshua Bloch, Effective Java 2.8

Для чего предназначен метод finalize()?
Какой недостаток у метода?
**Ответ.** Метод finalize выполняет роль деструктора ( метода который выполняется при разрушении объекта) и выполняется перед очисткой его из памяти.
В данном методе нельзя выполнять операции критичные по времени. Java не даёт никаких гарантий по поводу работы финализаторов, как и гарантий, что они вообще будут вызваны, поэтому их стоит избегать или использоваться как подстраховку.
**Источник.** Joshua Bloch, Effective Java 2.8

Для чего предназначены оболочечные классы?
Как они называются на инглише?
**Ответ.** Классы-оболочки (wrapper classes) представляеют собой представление примтивного типа объектом класса и применяются там, где необхождимо использовать объект.
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/numberclasses.html

В чем преимущество примитивных типов перед соответствующими оболочечными классами? 
**Ответ.** Примитивные типы проще и быстрее, не имеют проблем работы с объектами( прим. сравнение с помощью ==), при выполнении распаковки может произойти NullPointerEception.
А так же частая упаковка и рапаковка может привести к дорогостоющему и ненужному созданию объектов.
**Источник.**  Joshua Bloch, Effective Java 9.5

Что такое autoboxing и unboxing?
**Ответ.** Autoboxing - это автоматическое преобразование, которое компилятор Java выполняет между примитивными типами и соответствующими им классами-оболочками объектов. Обратный процесс называется unboxing.
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html

Дан код:
Integer a = 3, b =7;
Long c = a + b;
Перечислите все операции, где задействованы autoboxing и unboxing.
**Ответ.** 
	1) a = 3 (autoboxing)
	2) b = 7 (autoboxing)
	3) a + b (2 unboxing)
	4) c = ... (autoboxing)

Дан корректный раннер-класс. 
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()? 
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?
**Ответ.** Ошибки компиляции не будет, потому что компилятор посчитает, что этот метод является обычным методом класса.
Если мы попробуем отправить на выполнение, то компилятор попросит создать в классе правильный метод main.

Дан класс.
```
class Runner{
	public static void main(String[] args) {
        	System.out.println("Hello, world!");
	}
}
```
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!
**Ответ.**
```
class Runner{
	static{
        System.out.println("I am java.");
    }
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

Бонусное задание 1 (необязательное)
В задаче classes3 имеются два константных поля в классе покупки.
Им сразу присваиваются значения по умолчанию.
Например.
public class Purchase {
  public final static String PRODUCT_NAME = "milk";
  public final static int PRICE = 120;
  ...
}
Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла - константа в классе покупки.
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте константам PRODUCT_NAME и PRICE значения по умолчанию.
Для этого же примера начало класса должно быть таким:
public class Purchase {
  private static final String PRODUCT_NAME;
  private static final int PRICE;
  public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
  private static final String DEFAULT_PRODUCT_NAME = "milk";
  private static final int DEFAULT_PRICE = 120;
